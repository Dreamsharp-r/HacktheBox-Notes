Finding malware samples
	![[Pasted image 20240714190930.png]]

Evidence Collection for Digital Forensics
	![[Pasted image 20240714191115.png]]

Memory Collection Solutions
	![[Pasted image 20240714191240.png]]

Other Sites for Evidence Collection
	![[Pasted image 20240714191326.png]]

Malware Analysis Purpose
	- Detection and Classification
	- Reverse Engineering
	- Behavioral Analysis
	- Threat Intelligence

Techniques used
	- Static Analysis
	- Dynamic Analysis
	- Code Analysis
	- Memory Analysis
	- Malware unpacking

Windows Architecture at a High Level
![[Pasted image 20240714192222.png]]
	- Two types of modes:
		- User mode
			- System Support Processes (not Window Services)
				- winlogon.exe (logon process)
				- Session Manager (smss.exe)
				- Service Control Manager (services.exe)
			- Service Processes (Windows processes running in the background)
				- Windows Update Service
				- Task scheduler
				- Print Spooler
			- User Applications
				- 32-bit & 64-bit Applications. Interact with the OS via API
				- User mode -> API & system calls -> redirected to NTDLL.DLL transitioning from user mode to kernel mode where its executed -> Result is returned to user-mode 
			- Environment Subsystems (Provide execution environments for specific types of applications or processes)
				- Win32 Subsystem
				- POSIX
				- OS/2
			- Subsystem DLLs (Translate functions into calls)
				- Kernelbase.dll
				- user32.dll
				- wininet.dll
				- advapi32.dll
		- Kernel mode
			- Executive (Accessed via NTDLL.DLL)
				- I/O Manager
				- Object Manager
				- Security Reference Monitor
				- Process Manager
			- Kernel
				- Thread scheduling
				- Interrupt and exception dispatching
				- Multiprocessor synchronization
			- Device Drivers
				- Allows the OS to interact with hardware
			- Hardware Abstraction Layer (HAL)
				- Acts as a abstraction layer between hardware and the OS
			- Windowing and Graphic System (GUI)
				- Win32k.sys

How Interactions Occur
	![[Pasted image 20240714211521.png]]
	Shell.exe -> ReadProcessMemory is a Windows API Function -> Kernel32.DLL. This serves as the user mode interface to the Windows API. 
		-Kernel32.ll (part of NDLL.DLL) -> NTDLL.DLL -> Syscall -> NtReadVirtualMemory

Portable Executable
	- Used to encapsulate .exe, DLL, kernel modules (.srv), control panel applications (.cpl)
	![[Pasted image 20240714212303.png]]

Static Analysis on Linux
- Gathering information
	- File Type
	- File hash
	- Strings
	- Embedded elements
	- Packer Information
	- Imports
	- Exports
	- Assembly Code

Process by which to perform Static Analysis:
![[Pasted image 20240714222806.png]]
Cycle of Static Analysis for Linux:
1. File Type (file, hexdump)
2. Fingerprinting (MD5, SHA1, SHA256, IMPHASH, SSDEEP, Section Hashing)
3. File Hash Lookup (VirusTotal)
4. String Analysis (string, FLOSS)
5. Unpacking (UPX)

<u>Static Analysis on Linux</u>
- In Linux: To Find File Type
	- file /home/htb-student/samples/malwaresamples/ransomware.wannacry.exe
		- Shows the file type
	- hexdump -C /home/htb-student/samples/malwaresamples/ransomware.wannacry.exe | more
		- Seeing the ASCII string MZ (Hex: 4D 5A) denotes an .exe file.

- To Fingerprint the Malware (Create a unique identifier)
	- md5sum
		- md5sum [filepath]
	- SHA256
		- sha256sum [filepath]

Various other Hashing 
	- Malware authors can alter the file hash value by making minor modifications to the code. These techniques are designed to circumvent this
		- IMPHASH
		- Fuzzy Hashing (SSDEEP)
		- Section Hashing (Hashing PE Sections)
	
Import Hashing (IMPHASH)
	- IMPHASH is a hash calculated from fusing all the functions and generating a MD5 hash
		- Python code Pefile to calculate IMPHASH
		- Once created. python3 imphash_calc.py [filepath]
```- Code: python. Impash_calc.py

import sys
import pefile
import peutils

pe_file = sys.argv[1]
pe = pefile.PE(pe_file)
imphash = pe.get_imphash()

print(imphash)

```

- Also use Virustotal to find the IMPHASH via the MD5 or SHA256

Fuzzy Hashing (SSDEEP)
	- Break apart a file into small blocks and calculate the hash for each block. The resulting hashes are consolidated to generate a final fuzzy hash.
		- ssdeep [filepath]
		- ssdeep -pb *
			- Initiates matching mode (has to be on the directory where the malware samples are stored)
			- -p // denotes pretty matching mode
			- -b // denote display on the file names
	- ![[Pasted image 20240714230839.png]]

Section Hashing (Hashing PE Sections)
	- Breaks down a file into sections (.text, .rdata, .data, .rsrc)
	- Python code to calculate Section Hashing
	- Once created. python3 section_hashing.py [filepath]

```
Code: python.section_hashing.py

```python
import sys
import pefile
pe_file = sys.argv[1]
pe = pefile.PE(pe_file)
for section in pe.sections:
    print (section.Name, "MD5 hash:", section.get_hash_md5())
    print (section.Name, "SHA256 hash:", section.get_hash_sha256())
```

String Analysis
![[Pasted image 20240720210952.png]]
In the cmd
	- strings -n 15 [filepath]
	- n // specifies to print a sequence of at least the # specified
	- floss [filepath]
			- We may come across malware samples that's been compressed or obfuscated. 
			- A popular packer is Ultimate Packer for Executables (UPX)
			- upx -d -o
			- Use while we are on the directory where the packed malware is stored

Cycle of Static Analysis for Windows:
1. File Type (CFF Explorer)
2. Fingerprinting (Get-FileHash - MD5, SHA1, SHA256, IMPHASH, SSDEEP, Section Hashing)
3. File Hash Lookup (Virustotal)
4. String Analysis (string, FLOSS)
5. Unpacking (UPX)
		NOTE: On a Windows system, the presence of the ASCII string `MZ` (in hexadecimal: 4D 5A) at the start of a file (known as the "magic number") denotes an executable file. `MZ` stands for Mark Zbikowski, a key architect of MS-DOS

		Note: Creating IMPHASH
```python
import sys
import pefile
import peutils

pe_file = sys.argv[1]
pe = pefile.PE(pe_file)
imphash = pe.get_imphash()

print(imphash)
```

		Note: Creating Section Hashing
```python
import sys
import pefile
pe_file = sys.argv[1]
pe = pefile.PE(pe_file)
for section in pe.sections:
    print (section.Name, "MD5 hash:", section.get_hash_md5())
    print (section.Name, "SHA256 hash:", section.get_hash_sha256())```

Dynamic Analysis
- Analyzing the behavior of malware while its running and documenting its actions
	- Tools Used: 
		- Noriben
		- ProcMon
		- Wireshark
		- TCPdump
		- Fiddler 
		- Regshot
		- INetsSim
		- FakeDNS
		- FakeNet-NG

- Dynamic Analysis Procedure
	1. Environment Setup: Typically done in a VM
	2. Baseline Capture: Capture a snapshot of the VM
	3. Tool Deployment (pre-execution): Set up various tools to capture the activities of the malware
	4. Malware Execution
	5. Observation and Logging
	6. Analysis of collected data


Reverse Engineering (assembly code analysis/ Code analysis)
	- Process of deciphering the behavior and functionality of a compiled program
	- Two main tools: Disassemblers and Debuggers
		- Disassembler used for static analysis of the code
			- IDA
			- Cutter
			- Ghidra
		- Debugger used to disassemble code into assembly and can execute said code in a controller manner 
			- x32dbg
			- x64dbg
			- IDA
			- OllyDbg

Creating Detection Rules
	Acronyms:
		- YARA (Yet Another Recursive Acronym)
		- SIGMA

Creating Yara rules
	1. Download Yara specifically the yarGen tool
	2. Create a new directory with the applicable malware 
	3. Within the yarGen directory execute the following cmd line
		1. sudo python3 yarGen.py -m /[file directory of the new directory]
	4. A new file will be generated name yargen_rule.yar
	5. open the yara rule and can be customized

Detecting Malware using YARA rules
	1.  Copy the cmd
		1. yara /[file directory of yargen_rules.yar] /[file directory to search]
		2. Returns the malware presence

